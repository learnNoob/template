# 设计模式
## 组件的生命周期

> 组件的定义 （结构型模式）——组件的创建（创建型模式）——组件的服役（行为型模式）——组件的销毁

## 设计模式的七大原则

- 开闭原则（对扩展开放，对修改关闭）
- 里氏替换原则（继承父类而不是改变父类，不是改变父类的方法）
- 依赖倒置原则（面向接口编程，而不是面向实体类）
- 单一职责原则（每个类只负责自己的事情，而不是变成万能）
- 接口隔离原则（每个类建立自己的专用接口，而不是万能接口）
- 迪米特法则（无需直接交互的两个类，如果需要 交互，使用中间者）
- 合成复用原则（优先组合，其次继承，组合：把对方当成属性用）
## 创建型设计模式
- 将对象的创建和使用进行分离
- 降低系统的耦合度
- 使用者无需关注对象的创建细节
  - 对象的创建由相关的工厂来创建完成（各种工厂模式）
  - 对象的创建由一个建造者完成（建造者模式）
  - 对象的创建由原来对象对象克隆完成（原型模式）
  - 对象始终在系统中只有一个实例（单列模式） 

### 单列模式

> 对象始终在系统中只有一个实例

- 使用场景
  - 多线程中的线程池
  - 数据库连接池
  - 系统的环境信息
  - 上下文

- 面试问题
- - 系统的环境信息
  - spring是如何保持组件的单列的
  - servletContext是什么？是单列的吗？怎么保证
  - 数据库连接池是怎么创建出来的，怎么保证单列
  - ApplicationContext是什么？是单列的吗？怎么保证
    - ApplicationContext: tomcat:中一个应用，会有一个应用上下文信息
    - APPlicationContext: spring : 表示整个IOC容器

### 原型模式

> 用于重复的对象,同时又能保证效率

- 使用场景
  - 资源优化
  - 一个对象多个修改者的场景
  - 性能和安全要求
  - 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时可以用考虑使用原型模式拷贝多个对象供调用者使用
  - 深（两个对象不一样的[递归克隆]，内容却完全一样）、浅（只是属性赋值）

### 工厂模式

> 工厂模式提供了一种创建对象的最佳方式，我们不必关心对象的创建细节，只需要根据不同情况获取不同的产品

#### 使用场景

- NumberFormat、SimpleDateFormat
- LoggerFactory
- SqlSessionFactory
- BeanFactory

#### 简单工厂

- 角色
  - factory：工厂角色，Wulifactory
  - Product: 抽象产品，car
  - ConcreteProduct:具体产品角色，VanCar、MinCar

- 缺点

  > 违反开闭、扩展不易

#### 工厂方法

- 角色
  - Product抽象产品
  - ConscreteProduct:具体产品
  - Factory：抽象工厂
  - ConCreteFactory:具体工厂

- 缺点

  > 系统复杂形增加，产品单一

####  抽象工厂

> 工厂的工厂，解决产品单一的特点

### 建造者模式

> 创建的对象比较复杂，还必须暴露给使用者，屏蔽过程而不屏蔽细节

## 结构性模式

> 结构性设计模式关注点“怎样组合对象/类？”，所有我们关注类的组合关系
>
> - 类结构性模式关心类的组合，由多个类可以组合成一个更大的（继承）
> - 对象结构性模式关注类与对象的组合，通过关联关系在一个类中定义另一个类的实例对象（组合），根据“合成复用原则”，在系统中尽量使用关联关系来代替继承关系，因此大部分结构模式都是对象结构性模式

### 适配器模式

> 将一个接口转化成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，适配器模式分为类继承器模式和对象结构性继承器（组合）两种，前者（继承）类只间的耦ßß合度比较高，所有应用比较少

#### 角色

- 目标接口：可用是抽象类或接口，客户希望直接用的接口
- 适配者类：隐藏的转化接口
- 适配器类：他是一个转化器，通过继承或应用适配器对象，把适配器者接口转化成目标接口

#### 使用场景

- Tomcat如何将Request流转化成标准的Request;
- Spring AOP中的A dvisorAdapter是什么
- SpringMVC中经典的的HandleAdapter是什么
- Springboot中WebMVCConfigAdapter为什么存在又取消

### 桥接模式

