# 设计模式
## 组件的生命周期

> 组件的定义 （结构型模式）——组件的创建（创建型模式）——组件的服役（行为型模式）——组件的销毁

## 设计模式的七大原则

- 开闭原则（对扩展开放，对修改关闭）
- 里氏替换原则（继承父类而不是改变父类，不是改变父类的方法）
- 依赖倒置原则（面向接口编程，而不是面向实体类）
- 单一职责原则（每个类只负责自己的事情，而不是变成万能）
- 接口隔离原则（每个类建立自己的专用接口，而不是万能接口）
- 迪米特法则（无需直接交互的两个类，如果需要 交互，使用中间者）
- 合成复用原则（优先组合，其次继承，组合：把对方当成属性用）
## 创建型设计模式
- 将对象的创建和使用进行分离
- 降低系统的耦合度
- 使用者无需关注对象的创建细节
  - 对象的创建由相关的工厂来创建完成（各种工厂模式）
  - 对象的创建由一个建造者完成（建造者模式）
  - 对象的创建由原来对象对象克隆完成（原型模式）
  - 对象始终在系统中只有一个实例（单列模式） 

### 单列模式

> 对象始终在系统中只有一个实例

- 使用场景
  - 多线程中的线程池
  - 数据库连接池
  - 系统的环境信息
  - 上下文

- 面试问题
- - 系统的环境信息
  - spring是如何保持组件的单列的
  - servletContext是什么？是单列的吗？怎么保证
  - 数据库连接池是怎么创建出来的，怎么保证单列
  - ApplicationContext是什么？是单列的吗？怎么保证
    - ApplicationContext: tomcat:中一个应用，会有一个应用上下文信息
    - APPlicationContext: spring : 表示整个IOC容器

### 原型模式

> 用于重复的对象,同时又能保证效率

- 使用场景
  - 资源优化
  - 一个对象多个修改者的场景
  - 性能和安全要求
  - 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时可以用考虑使用原型模式拷贝多个对象供调用者使用
  - 深（两个对象不一样的[递归克隆]，内容却完全一样）、浅（只是属性赋值）

### 工厂模式

> 工厂模式提供了一种创建对象的最佳方式，我们不必关心对象的创建细节，只需要根据不同情况获取不同的产品

#### 使用场景

- NumberFormat、SimpleDateFormat
- LoggerFactory
- SqlSessionFactory
- BeanFactory

#### 简单工厂

- 角色
  - factory：工厂角色，Wulifactory
  - Product: 抽象产品，car
  - ConcreteProduct:具体产品角色，VanCar、MinCar

- 缺点

  > 违反开闭、扩展不易

#### 工厂方法

- 角色
  - Product抽象产品
  - ConscreteProduct:具体产品
  - Factory：抽象工厂  
  - ConCreteFactory:具体工厂

- 缺点

  > 系统复杂形增加，产品单一

####  抽象工厂

> 工厂的工厂，解决产品单一的特点

### 建造者模式

> 创建的对象比较复杂，还必须暴露给使用者，屏蔽过程而不屏蔽细节

## 结构性模式

> 结构性设计模式关注点“怎样组合对象/类？”，所有我们关注类的组合关系
>
> - 类结构性模式关心类的组合，由多个类可以组合成一个更大的（继承）
> - 对象结构性模式关注类与对象的组合，通过关联关系在一个类中定义另一个类的实例对象（组合），根据“合成复用原则”，在系统中尽量使用关联关系来代替继承关系，因此大部分结构模式都是对象结构性模式

### 适配器模式

> 将一个接口转化成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，适配器模式分为类继承器模式和对象结构性继承器（组合）两种，前者（继承）类只间的耦ßß合度比较高，所有应用比较少

#### 角色

- 目标接口：可用是抽象类或接口，客户希望直接用的接口
- 适配者类：隐藏的转化接口
- 适配器类：他是一个转化器，通过继承或应用适配器对象，把适配器者接口转化成目标接口

#### 使用场景

- Tomcat如何将Request流转化成标准的Request;
- Spring AOP中的A dvisorAdapter是什么
- SpringMVC中经典的的HandleAdapter是什么
- Springboot中WebMVCConfigAdapter为什么存在又取消

### 桥接模式

> - 将抽象与实现解偶，使两者都可以独立变化
> - 在系统设计期间，如果这个类里面的一些东西，会扩展很多，这个东西应该分离出来
> - 桥接将继承转为关联，降低类之间的耦合度，减少代码量

#### 角色

抽象化角色：定义抽象类，并包含一个对实现化对象的引用

扩展抽象化角色：是抽象化角色的子类，实现分类中的业务方法，并通过组合关系调用实现化角色中的业务方法

实现化角色：定义实现化角色的接口，提供扩展抽象化角色的调用

具体实现化角色：给出实现化角色接口的具体实现

#### 使用场景

- 当一个类存在两个独立变化的唯度，且这两个维度都需要进行扩展时
- 当一个不希望使用继承或因为多层次继承导致系统类的个数急剧增加时
- 当一个系统需要在构建的抽象化角色和具体角色之间增加更多的灵活性时
- inputStearReader

### 装饰器模式

> - 适配器是连接两个类，增强一个类，装饰器是增强一个类
> - 向一个现有的对象添加一个新的功能，同时又不改变其结构。属于对象结构性模式
> - 创建一个装饰类，用来包装原有的类，并在保持方法签名完整性的前提下，提供额外的功能

#### 场景

- SpringSession中如何进行session与redis关联？HttpRequestWrapper
- MybatisPlus提取了QueryWrapper
- Spring中BeanWrapper

### 门面模式/外观模式

> 是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更容易被访问的模式

### 享元模式（池、缓存）

## 行为设计模式

> - 行为设计模式关注怎样运行这些对象，类/对象运行时流程控制
> - 行为型模式用于描述程序在运行时复杂的流程控制
