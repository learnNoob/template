# 设计模式
## 组件的生命周期

> 组件的定义 （结构型模式）——组件的创建（创建型模式）——组件的服役（行为型模式）——组件的销毁

## 设计模式的七大原则

- 开闭原则（对扩展开放，对修改关闭）
- 里氏替换原则（继承父类而不是改变父类，不是改变父类的方法）
- 依赖倒置原则（面向接口编程，而不是面向实体类）
- 单一职责原则（每个类只负责自己的事情，而不是变成万能）
- 接口隔离原则（每个类建立自己的专用接口，而不是万能接口）
- 迪米特法则（无需直接交互的两个类，如果需要 交互，使用中间者）
- 合成复用原则（优先组合，其次继承，组合：把对方当成属性用）
## 创建型设计模式
- 将对象的创建和使用进行分离
- 降低系统的耦合度
- 使用者无需关注对象的创建细节
  - 对象的创建由相关的工厂来创建完成（各种工厂模式）
  - 对象的创建由一个建造者完成（建造者模式）
  - 对象的创建由原来对象对象克隆完成（原型模式）
  - 对象始终在系统中只有一个实例（单列模式） 

### 单列模式

> 对象始终在系统中只有一个实例

- 使用场景
  - 多线程中的线程池
  - 数据库连接池
  - 系统的环境信息
  - 上下文

- 面试问题
- - 系统的环境信息
  - spring是如何保持组件的单列的
  - servletContext是什么？是单列的吗？怎么保证
  - 数据库连接池是怎么创建出来的，怎么保证单列
  - ApplicationContext是什么？是单列的吗？怎么保证
    - ApplicationContext: tomcat:中一个应用，会有一个应用上下文信息
    - APPlicationContext: spring : 表示整个IOC容器

### 原型模式

> 用于重复的对象,同时又能保证效率

- 使用场景
  - 资源优化
  - 一个对象多个修改者的场景
  - 性能和安全要求
  - 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时可以用考虑使用原型模式拷贝多个对象供调用者使用
  - 深（两个对象不一样的[递归克隆]，内容却完全一样）、浅（只是属性赋值）

### 工厂模式

> 工厂模式提供了一种创建对象的最佳方式，我们不必关心对象的创建细节，只需要根据不同情况获取不同的产品

#### 简单工厂

- 角色
  - factory：工厂角色，Wulifactory
  - Product: 抽象产品，car
  - ConcreteProduct:具体产品角色，VanCar、MinCar

- 缺点

  > 违反开闭、扩展不易